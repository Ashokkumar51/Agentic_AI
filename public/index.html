<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hextris - Enhanced</title>
    <!-- EXTERNAL LIBRARIES -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="/socket.io/socket.io.js"></script>


    <!-- ================================================================================== -->
    <!--  CSS SECTION                                                                       -->
    <!-- ================================================================================== -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');

        body {
            margin: 0;
            background-color: #0f0c29;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            filter: drop-shadow(0 0 30px rgba(0, 0, 0, 0.6));
        }

        /* UI LAYERS */
        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
        }

        .stats-box {
            text-align: left;
        }

        .score-display {
            font-size: 3rem;
            font-weight: 900;
            line-height: 1;
            background: linear-gradient(180deg, #fff 0%, #aaa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sub-stat {
            font-size: 1rem;
            color: #ffde7d;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 4px;
        }

        .currency-tag {
            color: #08d9d6;
        }

        .right-stats {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }

        .lives-container {
            display: flex;
            gap: 5px;
            font-size: 1.5rem;
            color: #ff2e63;
        }

        /* Powerup Bar */
        .powerup-bar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        .power-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            font-size: 1.2rem;
        }

        .power-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .power-btn.active {
            border-color: #ffde7d;
            box-shadow: 0 0 15px #ffde7d;
            animation: pulse 1s infinite;
        }

        .power-btn.cooldown {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .power-cost {
            position: absolute;
            bottom: -18px;
            font-size: 0.7rem;
            font-weight: bold;
            color: #08d9d6;
            width: 100%;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Battle HUD */
        #battle-hud {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 220px;
            /* Slightly wider for scores */
            display: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rival-bar-bg {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .rival-bar-fill {
            height: 100%;
            background: #ff2e63;
            width: 0%;
            transition: width 0.2s linear;
        }

        .battle-scores {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-top: 4px;
            font-family: monospace;
        }

        .winning {
            color: #08d9d6;
        }

        .losing {
            color: #ff2e63;
            animation: pulse 1s infinite;
        }

        /* Notifications */
        .notification {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            white-space: nowrap;
            z-index: 20;
        }

        .notification.show {
            opacity: 1;
            animation: popUp 1s forwards;
        }

        /* Combo Counter */
        #combo-display {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: 900;
            color: #ffde7d;
            text-shadow: 0 0 20px rgba(255, 222, 125, 0.6);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.1s;
            z-index: 15;
        }

        #combo-display.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        /* Overdrive Overlay */
        #overdrive-overlay {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.3) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 5;
            mix-blend-mode: overlay;
        }

        #overdrive-overlay.active {
            opacity: 1;
            animation: pulseRed 0.5s infinite alternate;
        }

        /* Achievement Popup */
        .achievement-popup {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(16, 185, 129, 0.9);
            padding: 10px 20px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 30;
        }

        .achievement-popup.show {
            transform: translateX(-50%) translateY(0);
        }

        @keyframes popUp {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 222, 125, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 222, 125, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 222, 125, 0);
            }
        }

        @keyframes pulseRed {
            0% {
                opacity: 0.6;
            }

            100% {
                opacity: 1;
            }
        }

        /* Overlays */
        #overlay,
        #mode-select,
        #lobby-screen {
            position: absolute;
            inset: 0;
            background: rgba(10, 10, 31, 0.96);
            backdrop-filter: blur(16px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.4s ease;
        }

        .btn {
            background: #ff2e63;
            color: white;
            padding: 16px 48px;
            border-radius: 100px;
            font-size: 1.2rem;
            font-weight: 800;
            cursor: pointer;
            border: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 10px 30px rgba(255, 46, 99, 0.4);
            transition: all 0.2s;
            margin: 10px;
            min-width: 200px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(255, 46, 99, 0.6);
        }

        .btn-blue {
            background: #08d9d6;
            box-shadow: 0 10px 30px rgba(8, 217, 214, 0.4);
            color: #0f0c29;
        }

        .btn-blue:hover {
            box-shadow: 0 15px 40px rgba(8, 217, 214, 0.6);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: none;
            color: #aaa;
        }

        .btn-outline:hover {
            border-color: #fff;
            color: #fff;
            transform: none;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }

        .diff-btn {
            padding: 8px 16px;
            border: 2px solid #555;
            color: #555;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
        }

        .diff-btn.active {
            border-color: #08d9d6;
            color: #08d9d6;
            background: rgba(8, 217, 214, 0.1);
        }

        /* Lobby Inputs */
        .lobby-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #555;
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 20px;
            width: 280px;
            outline: none;
        }

        .lobby-input:focus {
            border-color: #08d9d6;
        }

        .hidden {
            display: none !important;
        }

        .music-indicator {
            opacity: 0.5;
        }

        .music-indicator.playing {
            opacity: 1;
            color: #08d9d6;
            text-shadow: 0 0 10px #08d9d6;
        }
    </style>
</head>

<body>

    <!-- ================================================================================== -->
    <!--  HTML SECTION                                                                      -->
    <!-- ================================================================================== -->
    <div id="game-container">
        <!-- Visual FX Layers -->
        <div id="overdrive-overlay"></div>
        <div id="combo-display">COMBO x2</div>

        <!-- Achievement Popup -->
        <div id="achievement-popup" class="achievement-popup">
            <i class="fas fa-trophy text-yellow-400 text-xl"></i>
            <span id="achievement-text">Unlocked: First Blood!</span>
        </div>

        <!-- UI Overlay -->
        <div class="ui-layer">
            <div class="top-bar">
                <div class="stats-box">
                    <div class="score-display" id="score">0</div>
                    <div class="sub-stat" id="level-tag">Level 1</div>
                    <div class="sub-stat currency-tag"><i class="fas fa-cube"></i> <span id="currency">0</span></div>

                    <div id="timer-display" class="hidden text-3xl font-black text-red-500 mt-2">60.00</div>
                </div>

                <div class="right-stats">
                    <div class="lives-container" id="lives-display">
                        <i class="fas fa-heart"></i><i class="fas fa-heart"></i><i class="fas fa-heart"></i>
                    </div>
                    <div id="battle-hud">

                        <div class="flex justify-between text-xs font-bold text-gray-400 uppercase">
                            <span>You</span>
                            <span id="rival-name-display">Rival</span>
                        </div>
                        <div class="rival-bar-bg">
                            <div class="rival-bar-fill" id="rival-bar"></div>
                        </div>

                        <div class="difficulty-selector">
                            <button class="diff-btn active" onclick="setDifficulty('LOW')">Low</button>
                            <button class="diff-btn" onclick="setDifficulty('MEDIUM')">Medium</button>
                            <button class="diff-btn" onclick="setDifficulty('HARD')">Hard</button>
                        </div>

                        <!-- NEW: Rival Numeric Score -->
                        <div class="battle-scores">
                            <span id="player-score-small">0</span>
                            <span id="rival-score-small">0</span>
                        </div>
                        <div class="text-center text-xs text-red-400 mt-1 font-mono" id="rival-status">CONNECTED</div>
                    </div>
                </div>
            </div>

            <div class="notification" id="notification"></div>

            <div class="powerup-bar">
                <div class="power-btn" id="btn-theme" title="Switch Theme"><i class="fas fa-palette"></i></div>
                <div class="power-btn" id="btn-hammer" title="Hammer (Free)"><i class="fas fa-hammer"></i></div>
                <div class="power-btn" id="btn-freeze" title="Time Freeze (50 Coins)">
                    <i class="fas fa-snowflake"></i>
                    <span class="power-cost">50</span>
                </div>
                <div class="power-btn" id="btn-hint" title="Hint (20 Coins)">
                    <i class="fas fa-lightbulb"></i>
                    <span class="power-cost">20</span>
                </div>
                <div class="power-btn music-indicator" id="btn-sound" title="Toggle Music/Sound"><i
                        class="fas fa-music"></i></div>
            </div>
        </div>

        <canvas id="canvas"></canvas>

        <!-- Mode Select Screen -->
        <div id="mode-select">
            <h1 class="text-6xl font-black mb-10 tracking-tighter text-white">HEXTRIS</h1>

            <div class="difficulty-selector">
                <button class="diff-btn" onclick="setDifficulty('EASY')">Easy</button>
                <button class="diff-btn active" onclick="setDifficulty('MEDIUM')">Medium</button>
                <button class="diff-btn" onclick="setDifficulty('HARD')">Hard</button>
            </div>

            <button class="btn" onclick="startGame('CLASSIC')">Classic Mode</button>
            <button class="btn btn-blue" onclick="startGame('TIMER')">Time Attack</button>
            <button class="btn btn-outline" onclick="openLobby()"><i class="fas fa-users"></i> Multiplayer</button>
            <button class="btn btn-blue" onclick="startGame('TEAM')">
                Team Battle
            </button>


            <div class="mt-8 text-sm text-gray-500">Daily Challenge: Score 5000 in Hard Mode</div>
        </div>

        <!-- Multiplayer Lobby -->
        <div id="lobby-screen" class="hidden">
            <h2 class="text-4xl font-bold mb-6 text-white">MULTIPLAYER LOBBY</h2>
            <input type="text" id="player-name" class="lobby-input" placeholder="Enter Nickname" maxlength="12">

            <div id="lobby-controls">
                <button class="btn btn-blue" onclick="findMatch()">Find Match</button>
                <button class="btn btn-outline" onclick="createRoom()">Create Room</button>
                <button class="btn btn-blue" onclick="joinRoom()">Join Room</button>
            </div>

            <div id="lobby-status" class="hidden text-xl text-[#08d9d6] font-mono mt-4 animate-pulse">Searching for
                players...</div>

            <button class="btn btn-outline mt-8 text-sm py-2" onclick="showMainMenu()">Back</button>
        </div>

        <!-- Game Over / Resume -->
        <div id="overlay" class="hidden">
            <h2 class="text-5xl font-black mb-4 text-white">GAME OVER</h2>
            <p id="final-score" class="text-2xl mb-2 text-[#ffde7d] font-bold">Score: 0</p>
            <p class="text-sm text-gray-400 mb-8">Currency Earned: <span id="earned-currency"
                    class="text-[#08d9d6]">0</span></p>

            <button class="btn btn-blue" id="resume-btn">Resume (-100 Coins)</button>
            <button class="btn btn-outline" onclick="showMainMenu()">Main Menu</button>
        </div>
    </div>

    <!-- ================================================================================== -->
    <!--  JS SECTION                                                                        -->
    <!-- ================================================================================== -->
    <script>
        const socket = io();
        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = false;
        let musicPlaying = false;
        let nextNoteTime = 0;
        let musicTimerID = null;
        let musicSequence = 0;

        const bassLine = [110, 110, 110, 110, 130.81, 130.81, 130.81, 130.81, 98, 98, 98, 98, 146.83, 146.83, 146.83, 146.83];
        const melodyLine = [440, 0, 523.25, 659.25, 523.25, 0, 440, 0, 392, 0, 493.88, 587.33, 493.88, 0, 392, 0];

        function scheduleNote() {
            if (!musicPlaying) return;
            const secondsPerBeat = 0.12;
            const now = audioCtx.currentTime;
            if (nextNoteTime < now + 0.1) {
                // Pitch shift based on level (NEW: Improved Visual/Audio Feedback)
                let detune = (state.level - 1) * 20;
                playTone(bassLine[musicSequence % 16] + (detune / 5), 'sawtooth', 0.1, 0.05);
                const melNote = melodyLine[musicSequence % 16];
                if (melNote > 0) playTone(melNote + detune, 'square', 0.1, 0.03);
                nextNoteTime += secondsPerBeat;
                musicSequence++;
            }
            musicTimerID = requestAnimationFrame(scheduleNote);
        }

        function toggleMusic() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (!musicPlaying) {
                musicPlaying = true;
                nextNoteTime = audioCtx.currentTime;
                musicSequence = 0;
                scheduleNote();
                document.getElementById('btn-sound').classList.add('playing');
            } else {
                musicPlaying = false;
                cancelAnimationFrame(musicTimerID);
                document.getElementById('btn-sound').classList.remove('playing');
            }
        }

        const playTone = (freq, type, duration, vol = 0.1) => {
            if (!soundEnabled && !musicPlaying) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        };

        const SFX = {
            move: () => playTone(200, 'triangle', 0.05, 0.05),
            match: () => playTone(600, 'sine', 0.3, 0.1),
            combo: () => { playTone(400, 'square', 0.1); setTimeout(() => playTone(800, 'square', 0.3), 100); },
            error: () => playTone(100, 'sawtooth', 0.4, 0.1),
            bomb: () => { playTone(100, 'sawtooth', 0.5, 0.2); playTone(50, 'square', 0.5, 0.2); },
            freeze: () => playTone(1200, 'sine', 1.0, 0.05),
            levelup: () => { playTone(400, 'sine', 0.1); setTimeout(() => playTone(600, 'sine', 0.1), 100); },
            heavyHit: () => playTone(150, 'square', 0.1, 0.2), // NEW: Heavy Hit
            achievement: () => { playTone(800, 'sine', 0.2); setTimeout(() => playTone(1200, 'sine', 0.4), 100); } // NEW: Achievement
        };

        // --- THEMES & CONFIG ---
        const THEMES = [
            { name: 'NEON', colors: ['#ff2e63', '#08d9d6', '#ffde7d', '#f08a5d', '#6a2c70', '#ffffff'], bg: '#0f0c29' },
            { name: 'PASTEL', colors: ['#FF9AA2', '#FFB7B2', '#FFDAC1', '#E2F0CB', '#B5EAD7', '#C7CEEA'], bg: '#2d3436' },
            { name: 'MATRIX', colors: ['#00ff00', '#00cc00', '#009900', '#006600', '#33ff33', '#114411'], bg: '#000000' },
            { name: 'CHAOS', colors: ['#ff0000', '#cc0000', '#990000', '#ff3333', '#ff6666', '#880000'], bg: '#1a0000' }
        ];
        let currentThemeIdx = 0;
        const HEX_RADIUS = 80;
        const BLOCK_HEIGHT = 24;
        const DEATH_LIMIT = 300;
        let SPAWN_DIST = 700;
        const COMBO_MAX_TIME = 2.0;

        // --- GAME STATE ---
        let state = {
            score: 0,
            currency: 100,
            lives: 3,
            ringCombo: 0,
            level: 1,
            teamA: 0,
            teamB: 0,
            teamMode: false,
            roomId: null,
            isHost: false,
            players: [],

            mode: 'CLASSIC',
            difficulty: 'MEDIUM',
            status: 'MENU',
            timeLeft: 60,
            rivalScore: 0,
            rivalRawScore: 0, // NEW: For number display
            rivalSpeed: 0.1,
            battleGraceTime: 0,
            frozen: false,
            blocks: [],
            stacks: [[], [], [], [], [], []], // Integers: 0-9 Normal, 10-19 Heavy, 20-29 Cracked
            rotation: 0,
            targetRotation: 0,
            lastTime: 0,
            spawnTimer: 0,
            gameSpeed: 2.0,
            hammerReady: true,
            mistakeCount: 0,
            isRotationLocked: false,
            playerName: 'Player',

            // NEW VARIABLES
            comboCount: 0,
            comboTimer: 0,
            particles: [],
            overdriveTimer: 0,
            isOverdrive: false,
            levelsWithoutDamage: 0,
            achievements: JSON.parse(localStorage.getItem('hextris_achievements') || '{}')
        };

        const DIFF_SETTINGS = {
            'EASY': { speedMod: 0.8, baseColors: 3, lives: 5 },
            'MEDIUM': { speedMod: 1.0, baseColors: 4, lives: 3 },
            'HARD': { speedMod: 1.3, baseColors: 5, lives: 1 }
        };

        // --- DOM ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const ui = {
            score: document.getElementById('score'),
            level: document.getElementById('level-tag'),
            currency: document.getElementById('currency'),
            timer: document.getElementById('timer-display'),
            lives: document.getElementById('lives-display'),
            overlay: document.getElementById('overlay'),
            modeSelect: document.getElementById('mode-select'),
            lobbyScreen: document.getElementById('lobby-screen'),
            resumeBtn: document.getElementById('resume-btn'),
            finalScore: document.getElementById('final-score'),
            notification: document.getElementById('notification'),
            btnHammer: document.getElementById('btn-hammer'),
            btnFreeze: document.getElementById('btn-freeze'),
            btnHint: document.getElementById('btn-hint'),
            container: document.getElementById('game-container'),
            rivalBar: document.getElementById('rival-bar'),
            rivalStatus: document.getElementById('rival-status'),
            battleHud: document.getElementById('battle-hud'),
            rivalNameDisplay: document.getElementById('rival-name-display'),
            // NEW UI ELEMENTS
            comboDisplay: document.getElementById('combo-display'),
            overdriveOverlay: document.getElementById('overdrive-overlay'),
            achievementPopup: document.getElementById('achievement-popup'),
            achievementText: document.getElementById('achievement-text'),
            playerScoreSmall: document.getElementById('player-score-small'),
            rivalScoreSmall: document.getElementById('rival-score-small')
        };

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- INPUTS ---
        window.addEventListener('keydown', e => {
            if (state.status !== 'PLAYING' || state.isRotationLocked) return;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') { state.targetRotation--; SFX.move(); }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') { state.targetRotation++; SFX.move(); }
            if (e.code === 'KeyP') togglePause();
            if (e.code === 'KeyH') usePowerup('HAMMER');
        });

        canvas.addEventListener('touchstart', e => {
            if (state.status !== 'PLAYING' || state.isRotationLocked) return;
            const x = e.touches[0].clientX;
            if (x < window.innerWidth / 2) state.targetRotation--;
            else state.targetRotation++;
            SFX.move();
            // ===== DYNAMIC SCREEN SHAKE =====
            let shakePower = Math.min(14, 4 + state.level); // stronger at higher level

            ui.container.style.transform =
                `translate(${Math.random() * shakePower - shakePower / 2}px, ${Math.random() * shakePower - shakePower / 2}px)`;

            setTimeout(() => {
                ui.container.style.transform = 'none';
            }, 80);
        }, { passive: true });

        // --- HELPER FUNCTIONS ---
        function unlockAchievement(id, title) {
            if (!state.achievements[id]) {
                state.achievements[id] = true;
                localStorage.setItem('hextris_achievements', JSON.stringify(state.achievements));
                ui.achievementText.innerText = `Unlocked: ${title}`;
                ui.achievementPopup.classList.add('show');
                SFX.achievement();
                setTimeout(() => ui.achievementPopup.classList.remove('show'), 3000);
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                state.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color
                });
            }
        }

        // --- UI FUNCTIONS ---
        window.setDifficulty = function (diff) {
            state.difficulty = diff;
            document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        }

        window.showMainMenu = function () {
            ui.overlay.classList.add('hidden');
            ui.lobbyScreen.classList.add('hidden');
            ui.modeSelect.classList.remove('hidden');
            ui.battleHud.style.display = 'none';
        }

        window.openLobby = function () {
            ui.modeSelect.classList.add('hidden');
            ui.lobbyScreen.classList.remove('hidden');
        }

        window.findMatch = function () {
            const name = document.getElementById('player-name').value || 'Guest';
            state.playerName = name;
            document.getElementById('lobby-controls').classList.add('hidden');
            document.getElementById('lobby-status').classList.remove('hidden');
            document.getElementById('lobby-status').innerText = "Searching for players...";
            setTimeout(() => {
                const opponents = ["HexMaster99", "PolygonSlayer", "GridRunner"];
                const opp = opponents[Math.floor(Math.random() * opponents.length)];
                document.getElementById('lobby-status').innerText = `Match Found: VS ${opp}`;
                ui.rivalNameDisplay.innerText = opp;
                setTimeout(() => startGame('BATTLE'), 1500);
            }, 2000);
        }
        socket.on("playerList", (players) => {

            document.getElementById('lobby-status').innerText =
                "Players:\n" + players.map(p => p.name).join("\n");

            // host starts game automatically
            if (players.length >= 2) {
                if (players[0].id === socket.id) {
                    setTimeout(() => socket.emit("startGame"), 1000);
                }
            }
        });


        socket.on("startGame", () => {
            startGame('BATTLE');
        });



        window.createRoom = function () {

            const name = document.getElementById('player-name').value || 'Host';
            state.playerName = name;

            socket.emit("createRoom", { name }, (roomId) => {

                document.getElementById('lobby-controls').classList.add('hidden');
                document.getElementById('lobby-status').classList.remove('hidden');

                document.getElementById('lobby-status').innerText =
                    "ROOM CODE: " + roomId + "\nWaiting for player...";
            });
        };


        window.joinRoom = function () {

            const name = document.getElementById('player-name').value || 'Guest';
            const code = prompt("Enter Room Code");

            socket.emit("joinRoom", { roomId: code, name }, (err) => {
                if (err) {
                    alert(err);
                    return;
                }

                document.getElementById('lobby-controls').classList.add('hidden');
                document.getElementById('lobby-status').classList.remove('hidden');
                document.getElementById('lobby-status').innerText = "Joining room...";
            });
        };




        window.startGame = function (mode) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            soundEnabled = true;
            if (!musicPlaying) toggleMusic();

            state.mode = mode;
            state.score = 0;
            state.level = 1;
            state.teamMode = (mode === 'TEAM');
            state.teamA = 0;
            state.teamB = 0;

            state.blocks = [];
            state.stacks = [[], [], [], [], [], []];
            state.status = 'PLAYING';
            state.spawnTimer = 0;
            state.rotation = 0;
            state.targetRotation = 0;
            state.frozen = false;
            state.mistakeCount = 0;
            state.timeLeft = 60;
            state.rivalScore = 0;
            state.rivalRawScore = 0;

            // NEW: Reset new state vars
            state.comboCount = 0;
            state.comboTimer = 0;
            state.particles = [];
            state.overdriveTimer = 0;
            state.isOverdrive = false;
            state.levelsWithoutDamage = 0;

            // Difficulty Config
            const settings = DIFF_SETTINGS[state.difficulty];
            state.gameSpeed = 2.0 * settings.speedMod;

            // FORCE 3 LIVES EVERY GAME
            state.lives = 3;


            // UI Reset
            ui.modeSelect.classList.add('hidden');
            ui.lobbyScreen.classList.add('hidden');
            ui.overlay.classList.add('hidden');
            ui.timer.classList.add('hidden');
            ui.battleHud.style.display = 'none';
            ui.currency.innerText = state.currency;
            ui.comboDisplay.classList.remove('active');
            ui.overdriveOverlay.classList.remove('active');
            document.getElementById('lobby-controls').classList.remove('hidden');
            document.getElementById('lobby-status').classList.add('hidden');

            if (mode === 'TIMER') ui.timer.classList.remove('hidden');
            if (mode === 'BATTLE') {
                ui.battleHud.style.display = 'block';
                let baseSpeed = settings.speedMod;
                if (state.difficulty === 'HARD') baseSpeed = 1.2;
                state.rivalSpeed = baseSpeed;
                state.battleGraceTime = 3.0;
                ui.rivalStatus.innerText = "READY...";
            }

            state.lastTime = performance.now();
            updateUI();
        }

        function togglePause() {
            state.status = state.status === 'PLAYING' ? 'PAUSED' : 'PLAYING';
            showNotification(state.status === 'PAUSED' ? "PAUSED" : "RESUME");
        }

        ui.resumeBtn.addEventListener('click', () => {
            if (state.currency >= 100) {
                state.currency -= 100;
                state.lives = Math.max(1, state.lives);
                state.status = 'PLAYING';
                state.frozen = false;
                state.stacks.forEach(s => { if (s.length > 5) s.length = 5; });
                state.blocks = [];
                ui.overlay.classList.add('hidden');
                updateUI();
            } else {
                showNotification("NOT ENOUGH COINS");
                SFX.error();
            }
        });

        document.getElementById('btn-theme').onclick = () => {
            currentThemeIdx = (currentThemeIdx + 1) % (THEMES.length - (state.score > 3000 ? 0 : 1));
            document.body.style.backgroundColor = THEMES[currentThemeIdx].bg;
        };
        document.getElementById('btn-sound').onclick = () => {
            soundEnabled = !soundEnabled;
            toggleMusic();
        };
        ui.btnHammer.onclick = () => usePowerup('HAMMER');
        ui.btnFreeze.onclick = () => usePowerup('FREEZE');
        ui.btnHint.onclick = () => usePowerup('HINT');

        function usePowerup(type) {
            if (state.status !== 'PLAYING') return;
            if (type === 'HAMMER' && state.hammerReady) {
                state.hammerReady = false;
                ui.btnHammer.classList.add('cooldown');
                setTimeout(() => { state.hammerReady = true; ui.btnHammer.classList.remove('cooldown'); }, 15000);

                // Enhanced Hammer: Destroys Heavies Instantly
                let max = -1, lane = 0;
                state.stacks.forEach((s, i) => { if (s.length > max) { max = s.length; lane = i; } });

                // Particle FX for hammer
                let topItem = state.stacks[lane][state.stacks[lane].length - 1];
                if (topItem !== undefined) {
                    let theme = THEMES[currentThemeIdx];
                    createParticles(canvas.width / 2, canvas.height / 2, theme.colors[topItem % 10]);
                }

                state.stacks[lane] = [];
                showNotification("SMASH!");
                SFX.bomb();
                shakeScreen();
            } else if (type === 'FREEZE') {
                if (state.currency >= 50) {
                    state.currency -= 50;
                    state.frozen = true;
                    showNotification("TIME FREEZE!");
                    SFX.freeze();
                    document.body.style.borderColor = "#08d9d6";
                    document.body.style.borderWidth = "5px";
                    document.body.style.borderStyle = "solid";
                    setTimeout(() => { state.frozen = false; document.body.style.borderWidth = "0px"; }, 5000);
                } else SFX.error();
            } else if (type === 'HINT') {
                if (state.currency >= 20) {
                    state.currency -= 20;
                    if (state.blocks.length > 0) {
                        let nextB = state.blocks[0];
                        let bestLane = -1;
                        for (let i = 0; i < 6; i++) {
                            let topColor = state.stacks[i][state.stacks[i].length - 1];
                            if (topColor && (topColor % 10) === (nextB.colorIdx % 10)) bestLane = i;
                        }
                        if (bestLane !== -1) {
                            showNotification(`AIM LANE ${bestLane + 1}`);
                            let diff = (bestLane - ((state.targetRotation % 6) + 6) % 6);
                            state.targetRotation += diff;
                        } else showNotification("ANY LANE OK");
                    }
                } else SFX.error();
            }
            updateUI();
        }

        // --- CORE LOGIC ---
        function spawnBlock() {
            if (state.frozen) return;

            // NEW: Dynamic Color Unlock
            const settings = DIFF_SETTINGS[state.difficulty];
            let maxColors = Math.min(6, settings.baseColors + Math.floor(state.level / 2));

            const worldLane = Math.floor(Math.random() * 6);
            const colorIdx = Math.floor(Math.random() * maxColors);
            let type = 'NORMAL';

            if (Math.random() < 0.05) type = 'BOMB';
            else if (Math.random() < 0.05) type = 'POLY';
            // NEW: Heavy Block Chance
            else if (Math.random() < 0.1) type = 'HEAVY';

            state.blocks.push({
                worldLane,
                dist: SPAWN_DIST,
                colorIdx: type === 'HEAVY' ? colorIdx + 10 : colorIdx, // Encode heavy
                type,
                polyTimer: 0
            });
        }

        function checkMatches() {
            let foundMatch = false;
            let theme = THEMES[currentThemeIdx];

            // 1. Ring Match
            let maxDepth = 0;
            state.stacks.forEach(s => maxDepth = Math.max(maxDepth, s.length));
            for (let d = 0; d < maxDepth; d++) {
                let c = state.stacks[0][d];
                if (c === undefined) continue;
                let ring = true;
                for (let l = 1; l < 6; l++) {
                    // Compare base colors (mod 10) so cracked blocks still match
                    if (!state.stacks[l][d] || (state.stacks[l][d] % 10) !== (c % 10)) { ring = false; break; }
                }
                if (ring) {
                    foundMatch = true;

                    // increase combo
                    state.ringCombo++;

                    let bonus = 1000 * state.ringCombo;
                    state.score += bonus;
                    state.currency += 20 * state.ringCombo;

                    // extra life every 3 rings
                    if (state.ringCombo % 3 === 0 && state.lives < 3) {
                        state.lives++;
                        showNotification("EXTRA LIFE!");
                    }

                    // slow motion
                    let oldSpeed = state.gameSpeed;
                    state.gameSpeed *= 0.4;
                    setTimeout(() => state.gameSpeed = oldSpeed, 500);

                    showNotification(`MEGA RING x${state.ringCombo} +${bonus}`);
                    SFX.combo();

                    // NEW: Ring Blast Particles
                    createParticles(canvas.width / 2, canvas.height / 2, '#ffffff');
                    unlockAchievement('ring_blast', 'First Ring Blast');

                    for (let l = 0; l < 6; l++) state.stacks[l].splice(d, 1);
                    if (state.mode === 'BATTLE') state.rivalScore = Math.max(0, state.rivalScore - 40);
                    updateUI();
                    return checkMatches();
                }
            }

            // 2. Cluster Match
            const visited = new Set();
            for (let l = 0; l < 6; l++) {
                for (let d = 0; d < state.stacks[l].length; d++) {
                    const val = state.stacks[l][d];
                    const cluster = findCluster(l, d, val % 10, visited); // Check using base color
                    if (cluster.length >= 3) {
                        foundMatch = true;

                        // NEW: Combo System
                        state.comboCount++;
                        state.comboTimer = COMBO_MAX_TIME;
                        let multiplier = Math.min(4, 1 + (state.comboCount * 0.5));
                        if (state.comboCount >= 2) {
                            ui.comboDisplay.innerText = `COMBO x${multiplier}`;
                            ui.comboDisplay.classList.add('active');
                            if (state.comboCount >= 5) unlockAchievement('combo_5', 'Combo Master');
                        }

                        SFX.match();
                        let pts = Math.floor(cluster.length * 50 * (state.level * 0.5 + 0.5) * multiplier);
                        state.score += pts;

                        if (state.score >= 5000) unlockAchievement('score_5000', 'High Scorer');
                        showNotification(`+${pts}`);

                        if (state.mode === 'BATTLE') state.rivalScore = Math.max(0, state.rivalScore - (cluster.length * 5));

                        // Process removals & damage
                        const lanes = [...new Set(cluster.map(c => c.lane))];

                        // Separate splice logic for heavy blocks
                        // We must process splices from top to bottom (descending depth)
                        // But heavier blocks stay, normal blocks leave.

                        cluster.forEach(c => {
                            // NEW: Particle FX at approximate block location
                            // We calculate simplified coord for FX
                            let angle = (c.lane * Math.PI * 2) / 6;
                            let dist = HEX_RADIUS + (c.depth * BLOCK_HEIGHT);
                            let px = (canvas.width / 2) + Math.cos(angle) * dist;
                            let py = (canvas.height / 2) + Math.sin(angle) * dist;
                            createParticles(px, py, theme.colors[state.stacks[c.lane][c.depth] % 10]);
                        });

                        // Logic: Mark blocks to remove. 
                        // If Heavy (10-19) -> Become Cracked (20-29). Don't remove.
                        // If Cracked (20-29) -> Remove.
                        // If Normal (0-9) -> Remove.

                        lanes.forEach(lid => {
                            let stack = state.stacks[lid];
                            let depthsToRemove = [];

                            // Find blocks in this lane belonging to cluster
                            let clusterBlocksInLane = cluster.filter(c => c.lane === lid);

                            clusterBlocksInLane.forEach(cb => {
                                let val = stack[cb.depth];
                                if (val >= 10 && val < 20) {
                                    // Heavy Full -> Cracked
                                    stack[cb.depth] = val + 10;
                                    SFX.heavyHit();
                                } else {
                                    // Normal or Cracked -> Remove
                                    depthsToRemove.push(cb.depth);
                                }
                            });

                            // Remove marked blocks (sort descending to not break indices)
                            depthsToRemove.sort((a, b) => b - a);
                            depthsToRemove.forEach(dd => stack.splice(dd, 1));
                        });

                        if (state.mode === 'TIMER') state.timeLeft += 2;
                    }
                }
            }
            if (foundMatch) {
                state.mistakeCount = 0;
                updateUI();
                setTimeout(() => checkMatches(), 250);
            }
        }

        function findCluster(lane, depth, baseColor, visited) {
            const k = `${lane},${depth}`;
            // Bound check
            if (!state.stacks[lane] || state.stacks[lane][depth] === undefined) return [];

            const itemColor = state.stacks[lane][depth] % 10;
            if (visited.has(k) || itemColor !== baseColor) return [];

            visited.add(k);
            let c = [{ lane, depth }];
            if (depth > 0) c = c.concat(findCluster(lane, depth - 1, baseColor, visited));
            if (depth < state.stacks[lane].length - 1) c = c.concat(findCluster(lane, depth + 1, baseColor, visited));
            c = c.concat(findCluster((lane + 5) % 6, depth, baseColor, visited));
            c = c.concat(findCluster((lane + 1) % 6, depth, baseColor, visited));
            return c;
        }

        function update(dt) {

            // NEW: Overdrive Event
            state.overdriveTimer += dt;
            if (state.overdriveTimer > 45 && !state.isOverdrive) {
                state.isOverdrive = true;
                state.gameSpeed *= 2;
                ui.overdriveOverlay.classList.add('active');
                showNotification("OVERDRIVE!");
                setTimeout(() => {
                    state.isOverdrive = false;
                    state.gameSpeed /= 2;
                    ui.overdriveOverlay.classList.remove('active');
                    state.overdriveTimer = 0;
                }, 3000);
            }

            // Particles
            for (let i = state.particles.length - 1; i >= 0; i--) {
                let p = state.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= dt * 2;
                if (p.life <= 0) state.particles.splice(i, 1);
            }

            // Combo decay
            if (state.comboCount > 0) {
                state.comboTimer -= dt;
                if (state.comboTimer <= 0) {
                    state.comboCount = 0;
                    ui.comboDisplay.classList.remove('active');
                }
            }

            let targetRad = state.targetRotation * (Math.PI / 3);
            state.rotation += (targetRad - state.rotation) * (15 * dt);

            state.spawnTimer += dt * 1000;
            let interval = Math.max(400, 1600 - (state.level * 150) - (state.score / 50));
            if (state.isOverdrive) interval = 200;

            if (state.status === 'PLAYING' && state.spawnTimer > interval) {
                spawnBlock();
                state.spawnTimer = 0;
            }

            // TIMER MODE
            if (state.mode === 'TIMER') {
                state.timeLeft -= dt;
                if (state.timeLeft <= 0) { state.lives = 0; gameOver(); }
            }

            // BATTLE MODE
            if (state.mode === 'BATTLE') {
                if (state.battleGraceTime > 0) {
                    state.battleGraceTime -= dt;
                    ui.rivalStatus.innerText = "PREPARE!";
                } else {
                    ui.rivalStatus.innerText = "FIGHT!";

                    let scoreDiff = state.score - state.rivalRawScore;
                    let aggression = 1.0;
                    if (scoreDiff > 2000) aggression = 1.3;
                    if (scoreDiff < -1000) aggression = 0.7;

                    let pts = (100 * state.rivalSpeed * aggression * dt);
                    if (state.teamMode) {
                        state.teamB += pts;
                    } else {
                        state.rivalRawScore += pts;
                    }

                    state.rivalScore += state.rivalSpeed * (1 + state.level * 0.1) * dt * 3;

                    if (state.rivalScore >= 100) {
                        state.ringCombo = 0;
                        state.rivalScore = 0;
                        showNotification("RIVAL STRIKE!");
                        SFX.error();
                        shakeScreen();
                        if (state.lives <= 0) gameOver();
                    }
                }
                updateUI();
            }

            // LEVEL UP
            if (state.score > state.level * 2000) {
                state.level++;
                state.gameSpeed += 0.2;
                state.currency += 20;

                state.levelsWithoutDamage++;
                if (state.levelsWithoutDamage >= 3) {
                    state.currency += 100;
                    showNotification("STREAK BONUS! +100");
                    state.levelsWithoutDamage = 0;
                } else {
                    showNotification("LEVEL UP!");
                }

                SFX.levelup();
                updateUI();
            }

            // BLOCK COLLISIONS
            for (let i = state.blocks.length - 1; i >= 0; i--) {
                const b = state.blocks[i];
                if (!state.frozen) b.dist -= state.gameSpeed * (1 + (state.level * 0.1));

                if (b.type === 'POLY') {
                    b.polyTimer += dt;
                    if (b.polyTimer > 0.5) {
                        b.colorIdx = (b.colorIdx + 1) % DIFF_SETTINGS[state.difficulty].baseColors;
                        b.polyTimer = 0;
                    }
                }

                const logicLane = (b.worldLane - (state.targetRotation % 6) + 6) % 6;
                const limit = HEX_RADIUS + (state.stacks[logicLane].length * BLOCK_HEIGHT);

                if (b.dist <= limit) {

                    state.blocks.splice(i, 1);

                    // COLLISION PARTICLES
                    let angle = (logicLane * Math.PI * 2) / 6;
                    let dist = HEX_RADIUS + (state.stacks[logicLane].length * BLOCK_HEIGHT);
                    let px = (canvas.width / 2) + Math.cos(angle) * dist;
                    let py = (canvas.height / 2) + Math.sin(angle) * dist;

                    for (let p = 0; p < 15 + state.level * 2; p++) {
                        state.particles.push({
                            x: px,
                            y: py,
                            vx: (Math.random() - 0.5) * (6 + state.level),
                            vy: (Math.random() - 0.5) * (6 + state.level),
                            life: 1,
                            color: THEMES[currentThemeIdx].colors[b.colorIdx % 10]
                        });
                    }

                    SFX.move();

                    if (b.type === 'BOMB') {
                        SFX.bomb();
                        showNotification("BOMB!");
                        state.stacks[logicLane].splice(-3);
                        shakeScreen();
                    } else {
                        state.stacks[logicLane].push(b.colorIdx);
                        checkMatches();
                    }

                    if ((state.stacks[logicLane].length * BLOCK_HEIGHT) + HEX_RADIUS >= DEATH_LIMIT) {
                        state.ringCombo = 0;
                        state.levelsWithoutDamage = 0;
                        SFX.error();
                        shakeScreen();
                        state.stacks[logicLane] = state.stacks[logicLane].slice(0, 3);
                        updateUI();
                        if (state.lives <= 0) gameOver();
                    }
                }
            }

            // ===== FINAL STEP  SEND SCORE TO SERVER =====
            if (state.mode === 'BATTLE') {
                socket.emit("scoreUpdate", state.score);
            }
        }


        function gameOver() {
            state.status = 'GAMEOVER';
            ui.finalScore.innerText = `Final Score: ${state.score}`;
            document.getElementById('earned-currency').innerText = Math.floor(state.score / 100);
            state.currency += Math.floor(state.score / 100);

            // NEW: No Damage Achievement check
            if (state.lives === 3 && state.score > 1000) {
                unlockAchievement('flawless', 'Flawless Run');
            }

            ui.overlay.classList.remove('hidden');
        }

        function shakeScreen() {
            ui.container.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
            setTimeout(() => ui.container.style.transform = 'none', 200);
        }
        function dynamicShake(power = 1) {

            // scale by level AND impact type
            let shakePower = Math.min(20, (3 + state.level * 0.8) * power);

            ui.container.style.transform =
                `translate(${Math.random() * shakePower - shakePower / 2}px,
                   ${Math.random() * shakePower - shakePower / 2}px)`;

            setTimeout(() => {
                ui.container.style.transform = 'none';
            }, 80 + power * 40);
        }


        function updateUI() {
            ui.score.innerText = state.score;
            ui.level.innerText = `LEVEL ${state.level}`;
            ui.currency.innerText = state.currency;
            ui.lives.innerHTML = '<i class="fas fa-heart"></i>'.repeat(state.lives);
            if (state.mode === 'TIMER') ui.timer.innerText = state.timeLeft.toFixed(1);
            if (state.mode === 'BATTLE') {
                ui.rivalBar.style.width = `${Math.min(100, state.rivalScore)}%`;
                // NEW: Numeric Scores
                if (state.teamMode) {
                    ui.playerScoreSmall.innerText = `TEAM A: ${Math.floor(state.teamA)}`;
                    ui.rivalScoreSmall.innerText = `TEAM B: ${Math.floor(state.teamB)}`;
                } else {
                    ui.playerScoreSmall.innerText = `YOU: ${state.score}`;
                    ui.rivalScoreSmall.innerText = `RIVAL: ${Math.floor(state.rivalRawScore)}`;
                }


                if (state.rivalScore > 80) ui.rivalBar.parentElement.style.boxShadow = "0 0 10px red";
                else ui.rivalBar.parentElement.style.boxShadow = "none";
            }
        }

        function showNotification(text) {
            ui.notification.innerText = text;
            ui.notification.classList.remove('show');
            void ui.notification.offsetWidth;
            ui.notification.classList.add('show');
        }

        // --- DRAWING ---
        function draw() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const cx = w / 2;
            const cy = h / 2;
            const theme = THEMES[currentThemeIdx];

            ctx.clearRect(0, 0, w, h);

            // Draw Rotation Indicator
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(state.rotation);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.moveTo(0, -HEX_RADIUS + 10);
            ctx.lineTo(10, -HEX_RADIUS + 30);
            ctx.lineTo(-10, -HEX_RADIUS + 30);
            ctx.fill();
            ctx.restore();

            // Danger Zone
            ctx.beginPath();
            ctx.arc(cx, cy, DEATH_LIMIT, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 46, 99, ${0.1 + (state.mistakeCount * 0.1)})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 10]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Center Hex
            drawHex(cx, cy, HEX_RADIUS, state.rotation + Math.PI / 6, '#252a34', true);
            drawHex(cx, cy, HEX_RADIUS - 5, state.rotation + Math.PI / 6, '#0f0c29', true);



            // Render Stacks
            for (let i = 0; i < 6; i++) {
                const angle = state.rotation + (i * Math.PI * 2) / 6;
                state.stacks[i].forEach((val, j) => {
                    drawBlock(cx, cy, HEX_RADIUS + (j * BLOCK_HEIGHT), angle, val, theme, 'NORMAL');
                });
            }
            // Render Falling
            state.blocks.forEach(b => {
                const worldAngle = (b.worldLane * Math.PI * 2) / 6;
                drawBlock(cx, cy, b.dist, worldAngle, b.colorIdx, theme, b.type);
            });

            // NEW: Render Particles
            state.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });
        }

        function drawHex(x, y, r, rot, color, fill) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = rot + (i * Math.PI * 2) / 6;
                ctx.lineTo(x + r * Math.cos(a), y + r * Math.sin(a));
            }
            ctx.closePath();
            ctx.fillStyle = color;
            if (fill) ctx.fill(); else ctx.stroke();
        }

        function drawBlock(cx, cy, d, angle, val, theme, type) {
            // Determine Color and Type from value
            // 0-9 Normal, 10-19 Heavy, 20-29 Cracked
            let colorIdx = val % 10;
            let isHeavy = (val >= 10 && val < 20) || type === 'HEAVY';
            let isCracked = (val >= 20 && val < 30);

            const color = theme.colors[colorIdx];
            const paddingScale = 0.96;
            const halfWidth = d * Math.tan(Math.PI / 6) * paddingScale;
            const h = BLOCK_HEIGHT - 2;
            const outerHalfWidth = (d + h) * Math.tan(Math.PI / 6) * paddingScale;
            const dirX = Math.cos(angle), dirY = Math.sin(angle);
            const perpX = -dirY, perpY = dirX;

            ctx.beginPath();
            ctx.moveTo(cx + d * dirX - halfWidth * perpX, cy + d * dirY - halfWidth * perpY);
            ctx.lineTo(cx + d * dirX + halfWidth * perpX, cy + d * dirY + halfWidth * perpY);
            ctx.lineTo(cx + (d + h) * dirX + outerHalfWidth * perpX, cy + (d + h) * dirY + outerHalfWidth * perpY);
            ctx.lineTo(cx + (d + h) * dirX - outerHalfWidth * perpX, cy + (d + h) * dirY - outerHalfWidth * perpY);
            ctx.closePath();

            ctx.fillStyle = color;
            if (type === 'BOMB') ctx.fillStyle = (Date.now() % 200 < 100) ? '#fff' : '#ff0000';
            if (type === 'POLY') ctx.fillStyle = theme.colors[Math.floor(Date.now() / 200) % 6];
            ctx.fill();

            // NEW: Heavy Block Visuals
            if (isHeavy || isCracked) {
                ctx.strokeStyle = "rgba(0,0,0,0.5)";
                ctx.lineWidth = 2;
                ctx.stroke();
                // Draw "Iron" overlay
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.fill();

                if (isCracked) {
                    // Draw cracks
                    ctx.beginPath();
                    ctx.moveTo(cx + (d + 5) * dirX, cy + (d + 5) * dirY);
                    ctx.lineTo(cx + (d + 15) * dirX + 5 * perpX, cy + (d + 15) * dirY + 5 * perpY);
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            const blockCx = cx + (d + h / 2) * dirX;
            const blockCy = cy + (d + h / 2) * dirY;
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            if (type === 'BOMB') {
                ctx.beginPath(); ctx.arc(blockCx, blockCy, 5, 0, Math.PI * 2); ctx.fill();
            } else if (!isHeavy && !isCracked) {
                if (colorIdx % 3 === 0) { ctx.beginPath(); ctx.arc(blockCx, blockCy, 4, 0, Math.PI * 2); ctx.fill(); }
                else if (colorIdx % 3 === 1) { ctx.fillRect(blockCx - 3, blockCy - 3, 6, 6); }
                else { ctx.beginPath(); ctx.moveTo(blockCx, blockCy - 4); ctx.lineTo(blockCx + 4, blockCy + 4); ctx.lineTo(blockCx - 4, blockCy + 4); ctx.fill(); }
            }
        }

        function main(now) {
            if (!state.lastTime) state.lastTime = now;
            const dt = Math.min(now - state.lastTime, 100) / 1000;
            state.lastTime = now;
            if (state.status === 'PLAYING') update(dt);
            draw();
            requestAnimationFrame(main);
        }
        // Listen for server start signal
        socket.on("startGame", () => {

            console.log("Server told to start match");

            document.getElementById('lobby-status').innerText = "Match Starting...";

            setTimeout(() => {
                startGame('BATTLE');
            }, 500);

        });


        updateUI();
        draw();
        requestAnimationFrame(main);

    </script>
</body>

</html>